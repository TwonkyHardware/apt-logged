#!/bin/bash

command=apt-get

# Is this a sudo command?  If yes, `$SUDO_USER` will be set
is_sudo=false
if [[ ! -z $SUDO_USER ]]; then
		is_sudo=true
fi

# The first thing to do is to check if an install/uninstall command is included
# in the argument list, because those are the only commands we care about.

# Use index $i to track positional parameter index.
# Ignore $0, the script name, and start at $1.
i=1
loggable=false
terms=()

# $@ expands to a list of all input parameters as separately quoted strings
# This does not include $0, the script name.
for arg in "$@"; do
		# See if an install/remove/purge command is present.
		if [[ ("$arg" = "install") || ("$arg" = "remove") || ("$arg" = "purge") ]]; then
				loggable=true
				command_index=$i
		fi

		# After having found the loggable command, add further arguments to terms[]
		# if they aren't flags
		if [ "$loggable" = true ]; then
				# Slice off the first character to make sure it's not a dash
				if [[ ! "${arg:0:1}" = '-' ]]; then
						# Add to the array of terms to be logged.
						# Parentheses are necessary, although because Bash script is a
						# moronic dogshit language by moronic dogshit people, you'll never
						# find a single source that explains why.
						terms+=("$arg")
				fi
		fi

		# Increment the index of the current parameter
		i=$((i+1))
done


# If this is not a loggable command, pass it along to the intended program
if [ "$loggable" = false ]; then
		if [ "$is_sudo" = true ]; then
				sudo /usr/bin/"$command" "$@"
				# Using 'return' causes error or warning output
				# "return: can only `return' from a function or sourced script"
				exit 0
		else
				/usr/bin/"$command" "$@"
				exit 0
		fi
fi


# Establish the logfile
# `apt[-get] (install | remove | purge)` must be run with sudo.
if [ "$is_sudo" = true ]; then
		logFile=/home/$SUDO_USER/.apt-get-install.log
else
		logFile=/home/$USER/.apt-get-install.log
fi

# Prep the log file.  If it doesn't exist, create it.
# `!`: "not"
# `-s`: File exists and has nonzero size
if [ ! -s $logFile ]; then
		# Create the file as the invoking user, unless not set
		#sudo -u ${SUDO_USER:-$USER} touch $logFile
		# The `logname` command returns the name of the logged in user, regardless
		# of whether that user has issued a command while acting as root.
		sudo -u $(logname) touch $logFile
		printf "# This is the package installation log generated by ~/bin/apt-get-log or ~/bin/apt-log, aliased to `apt-get` and `apt`, respectively,  in ~/.bash_aliases\n\n" >> $logFile
fi


# Now log the contents of terms[]
echo "Invoking alternate script ~/bin/$command-log"
echo "Logging '$command' activity to $logFile"

# Run the command
sudo /usr/bin/"$command" "$@"

# Capture the exit status of the install/remove/purge command
exitStatus=$?

# `%s` is substitution character
if [ $exitStatus == 0 ]; then
		printf "%s\t%s\t%s\t%s\t successful\n" "$(date)" "$(logname)" "$command" "$*" >> $logFile
else
		printf "%s\t%s\t%s\t%s\t unsuccessful\n" "$(date)" "$(logname)" "$command" "$*" >> $logFile
fi
