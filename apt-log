#!/bin/bash
# A script to log certain apt-get commands
# Commands to log:
#   $ sudo apt install/remove/purge (package or packages)
# including
#   $ sudo apt --purge remove (package or packages)
#   $ sudo apt remove --purge (package or packages)
# Commands to ignore:
#   $ sudo apt update/upgrade/autoremove
#   $ sudo apt install -f

# TODO: if '$ sudo apt install (package)' is executed for a package that's
# already installed, the command will return a success despite not actually
# installing anything, and this script will log a successful installation.
# See if there's a way to distinguish between the returns for the two cases.

# 'apt' and 'apt-get' commands are interchangeable for our purposes.
# Since the user might use either, we have to have a script for each.
# * `command=apt` makes this an alias script for 'apt'
# * `command=apt-get` makes this an alias script for 'apt-get'
command=apt-get

# Customize these if you wish
logFileName=.apt-install.log
logFile=/home/$(logname)/$logFileName

# Whether we log a command or not, the script will eventually pass along
# the command entered.  That includes passing along the use of 'sudo',
# so we must note if 'sudo' is being used.  If it is, `$SUDO_USER` will be set.
is_sudo=false
if [ $SUDO_USER ]; then
		is_sudo=true
fi

# The first thing to do is to check if an install/uninstall command is included
# in the argument list, because those are the only commands we care about.


# This block does the following:
# 1) Check for a key command (install/remove/purge) to see if we should log it.
# 2) Save every argument that isn't a key command or a flag to the list terms().
#    This will include package names targeted by the command.
loggable=false
terms=()
for arg in "$@"; do
		# See if an install/remove/purge command is present.
		if [[ ("$arg" = "install") || ("$arg" = "remove") || ("$arg" = "purge") ]]; then
				loggable=true
		elif [[ ! "${arg:0:1}" = '-' ]]; then
				# If not one of the key commands, check for flags by
				# slicing off the first character to if it's a dash.
				terms+=("$arg")
		fi
done

# If terms() is empty, then every argument was either a key command or a flag,
# as for
#    $ sudo apt install -f ,
# and there are no package names.  In this case, we don't log anything.
if [ "${#terms[@]}" -eq "0" ]; then
		loggable=false
fi


# If this is not a loggable command, pass it along to the intended program
if [ "$loggable" = false ]; then
		if [ "$is_sudo" = true ]; then
				sudo /usr/bin/"$command" "$@"
				exit 0
		else
				/usr/bin/"$command" "$@"
				exit 0
		fi
fi


# Prep the log file.  If it doesn't exist, create it.
if [ ! -s $logFile ]; then
		# Create the file as the invoking user
		sudo -u $(logname) touch $logFile
		# Print a header so the purpose of the file is clear
		printf "# This is the package installation log generated by ~/bin/apt-get-log or ~/bin/apt-log, aliased to 'apt-get' and 'apt', respectively, in ~/.bash_aliases\n\n" >> $logFile
fi


# Tell the user what's happening
echo "Invoking alternate script ~/bin/$command-log"
echo "Logging '$command' activity to $logFile"

# Run the command
sudo /usr/bin/"$command" "$@"

# Capture the exit status of the install/remove/purge command
exitStatus=$?

if [ $exitStatus == 0 ]; then
		status=successful
else
		status=unsuccessful
fi

printf "%s\t%s\t%s\t%s\t%s\n" "$(date)" "$(logname)" "$command" "$*" "$status" >> $logFile

